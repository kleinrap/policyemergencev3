Major tasks that would need to be performed:
- Add the fact that the external parties have selective states interest - this has very very large ramification throughout the entire code and cannot be implemented in steps without robust safeguards.
- Address the decrease in partial knowledge of all agents when participating in teams or coalitions are the partial knowledge is only transmitted between agents interacting leading to a small exchange of knowledge for all of the members.
- Find how to calculate the appropriate belonging level for agents which are in teams.
- Address the issue of initialisation of the policy hierarchy partial beliefs (3S). This has an major impact on the conflict level calculations.
	For the initialisation, how about relating that to the original awareness? More awareness would lead to better partial knowledge.
- Address the fact that for the conflict level of the shadow network of the teams, the full knowledge is used to constitute the conflict level which puts the teams at an advantage in their actions compared to individuals. (This is related to an assumption on the partial knowledge of teams)
	To solve this, select closest partial knowledge from all members to calculate conflict level. For coalitions, select randomly one of five closest. Add parameter for the randomness on partial knowledge acquisition.
	Awareness decay should be stopped when coalitions and teams perform inter and intra- actions. This applies to all members.

Research Questions:
- What is the real difference between coalitions and teams regarding partial knowledge sharing?

To do to make the model pluggable:
-!!! Purge the entire forest fire model (note, all functions below should be written in such a way that they can be easily rewritten for other models later on)
	- Create a function that reads the outputs from the model (reading from text file)
	- Create a new function for the calculation of the states
	- Create a new function where the policy instruments are defined
	- Create a function that will send the inputs
	- Within the model, introduce a way to stop the model to wait for the technical model to run
	- Centralise all new states and instruments update in the TechnicalModel.py file
	- Split the technical model input initialisation (instruments) and the agents initalisation
-! Create a file to save all outputs from the technical model
-! Differentiate how the inputs are set
-! Differentiate how the outputs are outputted
-! Differentiate how the experiments (batches) are run
- Reformat the initialisation files